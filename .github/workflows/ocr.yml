name: OCR PDFs to text

on:
  workflow_dispatch:
  schedule:
    - cron: "0 6 * * 1" # optional weekly run

jobs:
  ocr:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    permissions:
      contents: write

    concurrency:
      group: ocr-${{ github.ref }}
      cancel-in-progress: true

    steps:
      - name: Checkout (with LFS)
        uses: actions/checkout@v4
        with:
          lfs: true
          fetch-depth: 0

      - name: Pull LFS content
        run: |
          git lfs version || { sudo apt-get update && sudo apt-get install -y git-lfs; }
          git lfs install
          git lfs pull

      - name: Install OCR dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            ocrmypdf tesseract-ocr tesseract-ocr-eng poppler-utils qpdf ghostscript jq

      - name: OCR PDFs needing text
        id: ocr
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          mkdir -p texts
          MIN_BYTES=800
          changed=0

          need=0
          for f in pdfs/*.pdf; do
            b="${f##*/}"; b="${b%.pdf}"
            t="texts/$b.txt"
            if [ ! -s "$t" ] || [ $(wc -c < "$t") -lt $MIN_BYTES ]; then
              need=$((need+1))
            fi
          done
          echo "Needing OCR/text: $need files"

          for f in pdfs/*.pdf; do
            b="${f##*/}"; b="${b%.pdf}"
            t="texts/$b.txt"

            # Skip if already good
            if [ -s "$t" ] && [ $(wc -c < "$t") -ge $MIN_BYTES ]; then
              continue
            fi

            # 1) Embedded text
            if pdftotext -enc UTF-8 "$f" "$t.tmp" && [ $(wc -c < "$t.tmp") -ge $MIN_BYTES ]; then
              mv "$t.tmp" "$t"
              changed=1
              echo "pdftotext OK: $f"
              continue
            fi
            rm -f "$t.tmp" || true

            # 2) Decide OCR mode
            if pdftotext -enc UTF-8 "$f" - | head -c 1000 | tr -dc '[:alnum:]' | grep -q . ; then
              MODE="--redo-ocr"
            else
              MODE="--force-ocr"
            fi

            # 3) ocrmypdf (fast profile)
            echo "ocrmypdf $MODE: $f"
            ocrmypdf --optimize 0 --oversample 150 -j 2 --tesseract-timeout 900 \
              --sidecar "$t" $MODE "$f" out.pdf || true
            rm -f out.pdf

            # 4) Repair + retry
            if [ ! -s "$t" ] || [ $(wc -c < "$t") -lt $MIN_BYTES ]; then
              echo "Repair & retry: $f"
              qpdf --linearize --decrypt "$f" repaired.pdf || cp "$f" repaired.pdf
              ocrmypdf --optimize 0 --oversample 150 -j 2 --tesseract-timeout 900 \
                --sidecar "$t" $MODE repaired.pdf out.pdf || true
              rm -f repaired.pdf out.pdf
            fi

            # 5) Fallback (pdftoppm + tesseract)
            if [ ! -s "$t" ] || [ $(wc -c < "$t") -lt $MIN_BYTES ]; then
              echo "Fallback tesseract: $f"
              rm -f "$t"
              pdftoppm -r 170 -png "$f" p || true
              for p in p-*.png; do tesseract "$p" stdout --psm 6 -l eng || true; done > "$t"
              rm -f p-*.png
            fi

            if [ -s "$t" ] && [ $(wc -c < "$t") -ge $MIN_BYTES ]; then
              changed=1
              echo "OK: $f -> $t ($(wc -c < "$t") bytes)"
            else
              echo "FAILED: $f"
            fi
          done

          # Build manifest with jq (no Python)
          if ls texts/*.txt >/dev/null 2>&1; then
            jq -n '[inputs | {file:(input_filename|split("/")[-1]), bytes:(input|length), sample:(.[:400])}]' \
              texts/*.txt > texts/index_texts.json || true

            # If jq failed to produce a file, write a minimal JSON
            if [ ! -s texts/index_texts.json ]; then
              echo "[]" > texts/index_texts.json
              tmp=manifest.tmp
              : > "$tmp"
              while IFS= read -r -d '' f; do
                bytes=$(wc -c < "$f")
                sample=$(head -c 400 "$f" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g')
                printf '{"file":"%s","bytes":%s,"sample":"%s"}\n' \
                  "$(basename "$f")" "$bytes" "$sample" >> "$tmp"
              done < <(find texts -maxdepth 1 -name '*.txt' -print0)
              jq -s '.' "$tmp" > texts/index_texts.json || echo "[]" > texts/index_texts.json
              rm -f "$tmp"
            fi
          fi

          echo "changed=$changed" >> "$GITHUB_OUTPUT"

      - name: Commit & push results (rebase-safe)
        if: steps.ocr.outputs.changed == '1'
        run: |
          set -e
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git fetch origin main
          git pull --rebase origin main || true

          git add texts/*.txt texts/index_texts.json || true
          if git diff --staged --quiet; then
            echo "Nothing to commit"
            exit 0
          fi

          git commit -m "Add/update OCR text sidecars (CI)"

          for attempt in 1 2 3; do
            if git push; then
              echo "Push succeeded"
              break
            else
              echo "Push failed, retrying ($attempt)..."
              git pull --rebase origin main || true
            fi
          done
