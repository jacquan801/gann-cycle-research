name: OCR PDFs to text (parallel)

on:
  workflow_dispatch:
  schedule:
    - cron: "0 6 * * 1"

permissions:
  contents: write

jobs:
  ocr:
    runs-on: ubuntu-latest
    timeout-minutes: 120
    strategy:
      fail-fast: false
      matrix:
        shard: [0, 1, 2, 3]   # run 4 shards in parallel
    env:
      TOTAL_SHARDS: 4

    steps:
      - name: Checkout (with LFS)
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Pull LFS content
        run: |
          set -e
          git lfs install
          git lfs pull

      - name: Install OCR dependencies
        run: |
          set -e
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            ocrmypdf tesseract-ocr tesseract-ocr-eng poppler-utils qpdf ghostscript

      - name: Shard selection
        id: shard
        shell: bash
        run: |
          set -euo pipefail
          SHARD=${{ matrix.shard }}
          TOTAL=${{ env.TOTAL_SHARDS }}
          mkdir -p texts

          # Build ordered file list and select this shard's subset via modulo
          mapfile -d '' FILES < <(find pdfs -maxdepth 1 -type f -name '*.pdf' -print0 | sort -z)
          SEL=()
          i=0
          for f in "${FILES[@]}"; do
            if (( i % TOTAL == SHARD )); then SEL+=("$f"); fi
            ((i++))
          done

          echo "This is shard $SHARD of $TOTAL. Total PDFs: ${#FILES[@]}, this shard will process: ${#SEL[@]}"
          # Write selection to file for the next step
          printf '%s\0' "${SEL[@]}" > shard-files.list

      - name: OCR this shard
        shell: bash
        run: |
          set -euo pipefail
          MIN_BYTES=800
          changed=0

          # Iterate selected files only
          while IFS= read -r -d '' f; do
            base="${f##*/}"
            stem="${base%.pdf}"
            out="texts/${stem}.txt"

            # Skip if already good enough
            if [ -s "$out" ] && [ "$(wc -c < "$out")" -ge "$MIN_BYTES" ]; then
              continue
            fi

            # 1) Try embedded text
            if pdftotext -enc UTF-8 "$f" "$out.tmp" && [ "$(wc -c < "$out.tmp")" -ge "$MIN_BYTES" ]; then
              mv "$out.tmp" "$out"
              changed=1
              echo "pdftotext OK: $f"
              continue
            fi
            rm -f "$out.tmp" || true

            # 2) Choose OCR mode: redo if some text, else force
            if pdftotext -enc UTF-8 "$f" - | head -c 1000 | tr -dc '[:alnum:]' | grep -q . ; then
              MODE="--redo-ocr"
            else
              MODE="--force-ocr"
            fi

            # 3) ocrmypdf (fast profile)
            echo "ocrmypdf $MODE: $f"
            ocrmypdf --optimize 0 --oversample 150 -j 2 --tesseract-timeout 900 \
              --sidecar "$out" $MODE "$f" out.pdf || true
            rm -f out.pdf || true

            # 4) Repair + retry if still small
            if [ ! -s "$out" ] || [ "$(wc -c < "$out")" -lt "$MIN_BYTES" ]; then
              echo "Repair & retry: $f"
              qpdf --linearize --decrypt "$f" repaired.pdf || cp "$f" repaired.pdf
              ocrmypdf --optimize 0 --oversample 150 -j 2 --tesseract-timeout 900 \
                --sidecar "$out" $MODE repaired.pdf out.pdf || true
              rm -f repaired.pdf out.pdf || true
            fi

            # 5) Fallback: pdftoppm + tesseract
            if [ ! -s "$out" ] || [ "$(wc -c < "$out")" -lt "$MIN_BYTES" ]; then
              echo "Fallback tesseract: $f"
              rm -f "$out" || true
              pdftoppm -r 170 -png "$f" p || true
              for p in p-*.png; do tesseract "$p" "$p" --psm 6 -l eng || true; done
              cat p-*.png.txt > "$out" 2>/dev/null || true
              rm -f p-*.png p-*.png.txt || true
            fi

            if [ -s "$out" ] && [ "$(wc -c < "$out")" -ge "$MIN_BYTES" ]; then
              changed=1
              echo "OK: $f -> $out ($(wc -c < "$out") bytes)"
            else
              echo "FAILED: $f"
            fi

          done < shard-files.list

          # Stash whether this shard changed anything
          echo "changed=$changed" >> "$GITHUB_OUTPUT"

      - name: Commit shard results
        if: steps.ocr.outputs.changed == '1'
        run: |
          set -e
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase || true
          git add texts/*.txt || true
          git commit -m "Add/update OCR text (shard ${{ matrix.shard }})" || true
          git push || (sleep 3 && git pull --rebase && git push || true)

  manifest:
    runs-on: ubuntu-latest
    needs: ocr
    permissions:
      contents: write
    steps:
      - name: Checkout latest (with LFS)
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Build manifest
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p texts
          python - <<'PY'
import json, glob, os
items=[]
for t in sorted(glob.glob('texts/*.txt')):
    try:
        s=open(t,'r',errors='ignore').read()
        items.append({"file":os.path.basename(t),
                      "bytes":len(s.encode('utf-8','ignore')),
                      "sample":s[:400]})
    except Exception:
        items.append({"file":os.path.basename(t),"bytes":0,"sample":""})
open('texts/index_texts.json','w').write(json.dumps(items,ensure_ascii=False,indent=2))
PY

      - name: Commit manifest
        run: |
          set -e
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git pull --rebase || true
          git add texts/index_texts.json || true
          git commit -m "Update texts/index_texts.json" || true
          git push || (sleep 3 && git pull --rebase && git push || true)
